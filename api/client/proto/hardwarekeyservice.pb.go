// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: hardwarekeyservice.proto

package proto

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// PrivateKeyPolicy is a private key mode required for a client.
type PrivateKeyPolicy int32

const (
	// PRIVATE_KEY_POLICY_NONE means that the client can store their private keys
	// anywhere (usually on disk).
	PrivateKeyPolicy_PRIVATE_KEY_POLICY_NONE PrivateKeyPolicy = 0
	// PRIVATE_KEY_POLICY_HARDWARE_KEY means that the client must use a valid
	// hardware key to generate and store their private keys securely.
	PrivateKeyPolicy_PRIVATE_KEY_POLICY_HARDWARE_KEY PrivateKeyPolicy = 1
	// PRIVATE_KEY_POLICY_HARDWARE_KEY means that the client must use a valid
	// hardware key to generate and store their private keys securely, and
	// this key must require touch to be accessed and used.
	PrivateKeyPolicy_PRIVATE_KEY_POLICY_HARDWARE_KEY_TOUCH PrivateKeyPolicy = 2
)

var PrivateKeyPolicy_name = map[int32]string{
	0: "PRIVATE_KEY_POLICY_NONE",
	1: "PRIVATE_KEY_POLICY_HARDWARE_KEY",
	2: "PRIVATE_KEY_POLICY_HARDWARE_KEY_TOUCH",
}

var PrivateKeyPolicy_value = map[string]int32{
	"PRIVATE_KEY_POLICY_NONE":               0,
	"PRIVATE_KEY_POLICY_HARDWARE_KEY":       1,
	"PRIVATE_KEY_POLICY_HARDWARE_KEY_TOUCH": 2,
}

func (x PrivateKeyPolicy) String() string {
	return proto.EnumName(PrivateKeyPolicy_name, int32(x))
}

func (PrivateKeyPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d07261bf1b876cc5, []int{0}
}

// AttestHardwarePrivateKeyRequest is a request to AttestHardwarePrivateKey.
type AttestHardwarePrivateKeyRequest struct {
	// attestation_request is an attestation request for a hardware private key. The data
	// necessary for the request is dependent on the hardware key in question.
	//
	// Types that are valid to be assigned to AttestationRequest:
	//	*AttestHardwarePrivateKeyRequest_YubikeyAttestationRequest
	AttestationRequest   isAttestHardwarePrivateKeyRequest_AttestationRequest `protobuf_oneof:"attestation_request"`
	XXX_NoUnkeyedLiteral struct{}                                             `json:"-"`
	XXX_unrecognized     []byte                                               `json:"-"`
	XXX_sizecache        int32                                                `json:"-"`
}

func (m *AttestHardwarePrivateKeyRequest) Reset()         { *m = AttestHardwarePrivateKeyRequest{} }
func (m *AttestHardwarePrivateKeyRequest) String() string { return proto.CompactTextString(m) }
func (*AttestHardwarePrivateKeyRequest) ProtoMessage()    {}
func (*AttestHardwarePrivateKeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d07261bf1b876cc5, []int{0}
}
func (m *AttestHardwarePrivateKeyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttestHardwarePrivateKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttestHardwarePrivateKeyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttestHardwarePrivateKeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttestHardwarePrivateKeyRequest.Merge(m, src)
}
func (m *AttestHardwarePrivateKeyRequest) XXX_Size() int {
	return m.Size()
}
func (m *AttestHardwarePrivateKeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AttestHardwarePrivateKeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AttestHardwarePrivateKeyRequest proto.InternalMessageInfo

type isAttestHardwarePrivateKeyRequest_AttestationRequest interface {
	isAttestHardwarePrivateKeyRequest_AttestationRequest()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AttestHardwarePrivateKeyRequest_YubikeyAttestationRequest struct {
	YubikeyAttestationRequest *YubikeyAttestationRequest `protobuf:"bytes,1,opt,name=yubikey_attestation_request,json=yubikeyAttestationRequest,proto3,oneof" json:"yubikey_attestation_request,omitempty"`
}

func (*AttestHardwarePrivateKeyRequest_YubikeyAttestationRequest) isAttestHardwarePrivateKeyRequest_AttestationRequest() {
}

func (m *AttestHardwarePrivateKeyRequest) GetAttestationRequest() isAttestHardwarePrivateKeyRequest_AttestationRequest {
	if m != nil {
		return m.AttestationRequest
	}
	return nil
}

func (m *AttestHardwarePrivateKeyRequest) GetYubikeyAttestationRequest() *YubikeyAttestationRequest {
	if x, ok := m.GetAttestationRequest().(*AttestHardwarePrivateKeyRequest_YubikeyAttestationRequest); ok {
		return x.YubikeyAttestationRequest
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AttestHardwarePrivateKeyRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AttestHardwarePrivateKeyRequest_YubikeyAttestationRequest)(nil),
	}
}

// YubikeyAttestationRequest is data used to attest a specific Yubikey PIV slot.
type YubikeyAttestationRequest struct {
	// slot_cert is a certificate signed by the yubikey's attestation certificate using the slot's
	// public key.
	SlotCert []byte `protobuf:"bytes,1,opt,name=slot_cert,json=slotCert,proto3" json:"slot_cert,omitempty"`
	// attestation_cert is the attestation certificate signed by a Yubikey CA for the yubikey in
	// question.
	AttestationCert      []byte   `protobuf:"bytes,2,opt,name=attestation_cert,json=attestationCert,proto3" json:"attestation_cert,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *YubikeyAttestationRequest) Reset()         { *m = YubikeyAttestationRequest{} }
func (m *YubikeyAttestationRequest) String() string { return proto.CompactTextString(m) }
func (*YubikeyAttestationRequest) ProtoMessage()    {}
func (*YubikeyAttestationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d07261bf1b876cc5, []int{1}
}
func (m *YubikeyAttestationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *YubikeyAttestationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_YubikeyAttestationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *YubikeyAttestationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_YubikeyAttestationRequest.Merge(m, src)
}
func (m *YubikeyAttestationRequest) XXX_Size() int {
	return m.Size()
}
func (m *YubikeyAttestationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_YubikeyAttestationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_YubikeyAttestationRequest proto.InternalMessageInfo

func (m *YubikeyAttestationRequest) GetSlotCert() []byte {
	if m != nil {
		return m.SlotCert
	}
	return nil
}

func (m *YubikeyAttestationRequest) GetAttestationCert() []byte {
	if m != nil {
		return m.AttestationCert
	}
	return nil
}

// AttestHardwarePrivateKeyResponse is a response to AttestHardwarePrivateKey.
type AttestHardwarePrivateKeyResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AttestHardwarePrivateKeyResponse) Reset()         { *m = AttestHardwarePrivateKeyResponse{} }
func (m *AttestHardwarePrivateKeyResponse) String() string { return proto.CompactTextString(m) }
func (*AttestHardwarePrivateKeyResponse) ProtoMessage()    {}
func (*AttestHardwarePrivateKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d07261bf1b876cc5, []int{2}
}
func (m *AttestHardwarePrivateKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttestHardwarePrivateKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttestHardwarePrivateKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttestHardwarePrivateKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttestHardwarePrivateKeyResponse.Merge(m, src)
}
func (m *AttestHardwarePrivateKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *AttestHardwarePrivateKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AttestHardwarePrivateKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AttestHardwarePrivateKeyResponse proto.InternalMessageInfo

// GetPrivateKeyPolicyRequest is a request to GetPrivateKeyPolicy.
type GetPrivateKeyPolicyRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetPrivateKeyPolicyRequest) Reset()         { *m = GetPrivateKeyPolicyRequest{} }
func (m *GetPrivateKeyPolicyRequest) String() string { return proto.CompactTextString(m) }
func (*GetPrivateKeyPolicyRequest) ProtoMessage()    {}
func (*GetPrivateKeyPolicyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d07261bf1b876cc5, []int{3}
}
func (m *GetPrivateKeyPolicyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPrivateKeyPolicyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPrivateKeyPolicyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPrivateKeyPolicyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPrivateKeyPolicyRequest.Merge(m, src)
}
func (m *GetPrivateKeyPolicyRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetPrivateKeyPolicyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPrivateKeyPolicyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetPrivateKeyPolicyRequest proto.InternalMessageInfo

// GetPrivateKeyPolicyResponse is a response to GetPrivateKeyPolicy.
type GetPrivateKeyPolicyResponse struct {
	// policy is the private key policy enforced for the current user.
	Policy               PrivateKeyPolicy `protobuf:"varint,1,opt,name=policy,proto3,enum=proto.PrivateKeyPolicy" json:"policy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *GetPrivateKeyPolicyResponse) Reset()         { *m = GetPrivateKeyPolicyResponse{} }
func (m *GetPrivateKeyPolicyResponse) String() string { return proto.CompactTextString(m) }
func (*GetPrivateKeyPolicyResponse) ProtoMessage()    {}
func (*GetPrivateKeyPolicyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d07261bf1b876cc5, []int{4}
}
func (m *GetPrivateKeyPolicyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPrivateKeyPolicyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPrivateKeyPolicyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPrivateKeyPolicyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPrivateKeyPolicyResponse.Merge(m, src)
}
func (m *GetPrivateKeyPolicyResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetPrivateKeyPolicyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPrivateKeyPolicyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetPrivateKeyPolicyResponse proto.InternalMessageInfo

func (m *GetPrivateKeyPolicyResponse) GetPolicy() PrivateKeyPolicy {
	if m != nil {
		return m.Policy
	}
	return PrivateKeyPolicy_PRIVATE_KEY_POLICY_NONE
}

func init() {
	proto.RegisterEnum("proto.PrivateKeyPolicy", PrivateKeyPolicy_name, PrivateKeyPolicy_value)
	proto.RegisterType((*AttestHardwarePrivateKeyRequest)(nil), "proto.AttestHardwarePrivateKeyRequest")
	proto.RegisterType((*YubikeyAttestationRequest)(nil), "proto.YubikeyAttestationRequest")
	proto.RegisterType((*AttestHardwarePrivateKeyResponse)(nil), "proto.AttestHardwarePrivateKeyResponse")
	proto.RegisterType((*GetPrivateKeyPolicyRequest)(nil), "proto.GetPrivateKeyPolicyRequest")
	proto.RegisterType((*GetPrivateKeyPolicyResponse)(nil), "proto.GetPrivateKeyPolicyResponse")
}

func init() { proto.RegisterFile("hardwarekeyservice.proto", fileDescriptor_d07261bf1b876cc5) }

var fileDescriptor_d07261bf1b876cc5 = []byte{
	// 375 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x92, 0xef, 0x4a, 0xfa, 0x50,
	0x1c, 0xc6, 0x3d, 0xc2, 0x4f, 0x7e, 0x7d, 0x93, 0x1a, 0x47, 0xc2, 0x3f, 0x0b, 0xb5, 0x45, 0x7f,
	0xec, 0x85, 0x81, 0x5d, 0xc1, 0x34, 0x69, 0x62, 0xe8, 0x58, 0x56, 0x08, 0xc1, 0x98, 0xeb, 0x0b,
	0x0d, 0xc5, 0xd9, 0xd9, 0xd1, 0xd8, 0xab, 0x6e, 0xa4, 0x0b, 0xea, 0x65, 0x77, 0x50, 0x78, 0x25,
	0xe1, 0xd9, 0x44, 0xa9, 0x2d, 0x5f, 0x0d, 0x9e, 0xe7, 0xf3, 0x3c, 0x9c, 0x3d, 0xe7, 0x40, 0xee,
	0xc9, 0x62, 0x8f, 0x2f, 0x16, 0xc3, 0x21, 0xfa, 0x1e, 0xb2, 0x99, 0x63, 0x63, 0x75, 0xc2, 0x5c,
	0xee, 0xd2, 0x7f, 0xe2, 0xa3, 0xbc, 0x11, 0x28, 0xa9, 0x9c, 0xa3, 0xc7, 0xb5, 0x90, 0xd4, 0x99,
	0x33, 0xb3, 0x38, 0xb6, 0xd1, 0x37, 0xf0, 0x79, 0x8a, 0x1e, 0xa7, 0x03, 0x90, 0xfd, 0xe9, 0xc0,
	0x19, 0xa2, 0x6f, 0x5a, 0x02, 0xb5, 0xb8, 0xe3, 0x8e, 0x4d, 0x16, 0xd8, 0x39, 0x52, 0x26, 0xa7,
	0xdb, 0xb5, 0x72, 0xd0, 0x5b, 0xed, 0x07, 0xa4, 0xba, 0x02, 0xc3, 0x1a, 0x2d, 0x61, 0xe4, 0xfd,
	0x38, 0xb3, 0xbe, 0x07, 0x99, 0x88, 0x6e, 0xc5, 0x86, 0x7c, 0x6c, 0x21, 0x95, 0x61, 0xcb, 0x1b,
	0xb9, 0xdc, 0xb4, 0x91, 0x05, 0xa7, 0x48, 0x1b, 0xff, 0x17, 0x42, 0x03, 0x19, 0xa7, 0x15, 0x90,
	0xd6, 0x0b, 0x05, 0x93, 0x14, 0xcc, 0xee, 0x9a, 0xbe, 0x40, 0x15, 0x05, 0xca, 0xf1, 0x13, 0x78,
	0x13, 0x77, 0xec, 0xa1, 0xb2, 0x0f, 0x85, 0x2b, 0xe4, 0x2b, 0x43, 0x77, 0x47, 0x8e, 0xbd, 0x5c,
	0x48, 0xe9, 0x80, 0x1c, 0xe9, 0x06, 0x61, 0x7a, 0x0e, 0xa9, 0x89, 0x50, 0xc4, 0x29, 0x77, 0x6a,
	0xd9, 0x70, 0xab, 0x5f, 0x81, 0x10, 0x3b, 0x7b, 0x05, 0xe9, 0xa7, 0x47, 0x65, 0xc8, 0xea, 0x46,
	0xeb, 0x4e, 0xed, 0x35, 0xcd, 0x76, 0xb3, 0x6f, 0xea, 0xdd, 0xeb, 0x56, 0xa3, 0x6f, 0x76, 0xba,
	0x9d, 0xa6, 0x94, 0xa0, 0x87, 0x50, 0x8a, 0x30, 0x35, 0xd5, 0xb8, 0xbc, 0x57, 0x0d, 0xa1, 0x49,
	0x84, 0x56, 0xe0, 0x68, 0x03, 0x64, 0xf6, 0xba, 0xb7, 0x0d, 0x4d, 0x4a, 0xd6, 0x3e, 0x09, 0xd0,
	0xe5, 0x1a, 0x6d, 0xf4, 0x6f, 0x82, 0xa7, 0x43, 0x87, 0x90, 0x8b, 0x5b, 0x8a, 0x1e, 0x87, 0x3f,
	0xb5, 0xe1, 0x35, 0x15, 0x4e, 0x36, 0x72, 0xe1, 0x6a, 0x0f, 0x90, 0x89, 0x18, 0x95, 0x1e, 0x84,
	0xf9, 0xf8, 0xeb, 0x28, 0x28, 0x7f, 0x21, 0x41, 0x7b, 0x3d, 0xfd, 0x3e, 0x2f, 0x92, 0x8f, 0x79,
	0x91, 0x7c, 0xcd, 0x8b, 0x64, 0x90, 0x12, 0x81, 0x8b, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0xa4,
	0x66, 0xf9, 0x57, 0x30, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// HardwareKeyServiceClient is the client API for HardwareKeyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type HardwareKeyServiceClient interface {
	// AttestHardwarePrivateKey is used to perform a server-side attestation check for a
	// hardware-backed private key.
	AttestHardwarePrivateKey(ctx context.Context, in *AttestHardwarePrivateKeyRequest, opts ...grpc.CallOption) (*AttestHardwarePrivateKeyResponse, error)
	// GetPrivateKeyPolicy is used to find a user's private key storage requirements.
	GetPrivateKeyPolicy(ctx context.Context, in *GetPrivateKeyPolicyRequest, opts ...grpc.CallOption) (*GetPrivateKeyPolicyResponse, error)
}

type hardwareKeyServiceClient struct {
	cc *grpc.ClientConn
}

func NewHardwareKeyServiceClient(cc *grpc.ClientConn) HardwareKeyServiceClient {
	return &hardwareKeyServiceClient{cc}
}

func (c *hardwareKeyServiceClient) AttestHardwarePrivateKey(ctx context.Context, in *AttestHardwarePrivateKeyRequest, opts ...grpc.CallOption) (*AttestHardwarePrivateKeyResponse, error) {
	out := new(AttestHardwarePrivateKeyResponse)
	err := c.cc.Invoke(ctx, "/proto.HardwareKeyService/AttestHardwarePrivateKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hardwareKeyServiceClient) GetPrivateKeyPolicy(ctx context.Context, in *GetPrivateKeyPolicyRequest, opts ...grpc.CallOption) (*GetPrivateKeyPolicyResponse, error) {
	out := new(GetPrivateKeyPolicyResponse)
	err := c.cc.Invoke(ctx, "/proto.HardwareKeyService/GetPrivateKeyPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HardwareKeyServiceServer is the server API for HardwareKeyService service.
type HardwareKeyServiceServer interface {
	// AttestHardwarePrivateKey is used to perform a server-side attestation check for a
	// hardware-backed private key.
	AttestHardwarePrivateKey(context.Context, *AttestHardwarePrivateKeyRequest) (*AttestHardwarePrivateKeyResponse, error)
	// GetPrivateKeyPolicy is used to find a user's private key storage requirements.
	GetPrivateKeyPolicy(context.Context, *GetPrivateKeyPolicyRequest) (*GetPrivateKeyPolicyResponse, error)
}

// UnimplementedHardwareKeyServiceServer can be embedded to have forward compatible implementations.
type UnimplementedHardwareKeyServiceServer struct {
}

func (*UnimplementedHardwareKeyServiceServer) AttestHardwarePrivateKey(ctx context.Context, req *AttestHardwarePrivateKeyRequest) (*AttestHardwarePrivateKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttestHardwarePrivateKey not implemented")
}
func (*UnimplementedHardwareKeyServiceServer) GetPrivateKeyPolicy(ctx context.Context, req *GetPrivateKeyPolicyRequest) (*GetPrivateKeyPolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPrivateKeyPolicy not implemented")
}

func RegisterHardwareKeyServiceServer(s *grpc.Server, srv HardwareKeyServiceServer) {
	s.RegisterService(&_HardwareKeyService_serviceDesc, srv)
}

func _HardwareKeyService_AttestHardwarePrivateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttestHardwarePrivateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HardwareKeyServiceServer).AttestHardwarePrivateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.HardwareKeyService/AttestHardwarePrivateKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HardwareKeyServiceServer).AttestHardwarePrivateKey(ctx, req.(*AttestHardwarePrivateKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HardwareKeyService_GetPrivateKeyPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPrivateKeyPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HardwareKeyServiceServer).GetPrivateKeyPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.HardwareKeyService/GetPrivateKeyPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HardwareKeyServiceServer).GetPrivateKeyPolicy(ctx, req.(*GetPrivateKeyPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _HardwareKeyService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.HardwareKeyService",
	HandlerType: (*HardwareKeyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AttestHardwarePrivateKey",
			Handler:    _HardwareKeyService_AttestHardwarePrivateKey_Handler,
		},
		{
			MethodName: "GetPrivateKeyPolicy",
			Handler:    _HardwareKeyService_GetPrivateKeyPolicy_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "hardwarekeyservice.proto",
}

func (m *AttestHardwarePrivateKeyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttestHardwarePrivateKeyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttestHardwarePrivateKeyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AttestationRequest != nil {
		{
			size := m.AttestationRequest.Size()
			i -= size
			if _, err := m.AttestationRequest.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AttestHardwarePrivateKeyRequest_YubikeyAttestationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttestHardwarePrivateKeyRequest_YubikeyAttestationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.YubikeyAttestationRequest != nil {
		{
			size, err := m.YubikeyAttestationRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHardwarekeyservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *YubikeyAttestationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *YubikeyAttestationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *YubikeyAttestationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AttestationCert) > 0 {
		i -= len(m.AttestationCert)
		copy(dAtA[i:], m.AttestationCert)
		i = encodeVarintHardwarekeyservice(dAtA, i, uint64(len(m.AttestationCert)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SlotCert) > 0 {
		i -= len(m.SlotCert)
		copy(dAtA[i:], m.SlotCert)
		i = encodeVarintHardwarekeyservice(dAtA, i, uint64(len(m.SlotCert)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AttestHardwarePrivateKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttestHardwarePrivateKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttestHardwarePrivateKeyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *GetPrivateKeyPolicyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPrivateKeyPolicyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPrivateKeyPolicyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *GetPrivateKeyPolicyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPrivateKeyPolicyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPrivateKeyPolicyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Policy != 0 {
		i = encodeVarintHardwarekeyservice(dAtA, i, uint64(m.Policy))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintHardwarekeyservice(dAtA []byte, offset int, v uint64) int {
	offset -= sovHardwarekeyservice(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AttestHardwarePrivateKeyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AttestationRequest != nil {
		n += m.AttestationRequest.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttestHardwarePrivateKeyRequest_YubikeyAttestationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.YubikeyAttestationRequest != nil {
		l = m.YubikeyAttestationRequest.Size()
		n += 1 + l + sovHardwarekeyservice(uint64(l))
	}
	return n
}
func (m *YubikeyAttestationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SlotCert)
	if l > 0 {
		n += 1 + l + sovHardwarekeyservice(uint64(l))
	}
	l = len(m.AttestationCert)
	if l > 0 {
		n += 1 + l + sovHardwarekeyservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttestHardwarePrivateKeyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetPrivateKeyPolicyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetPrivateKeyPolicyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Policy != 0 {
		n += 1 + sovHardwarekeyservice(uint64(m.Policy))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovHardwarekeyservice(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozHardwarekeyservice(x uint64) (n int) {
	return sovHardwarekeyservice(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AttestHardwarePrivateKeyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHardwarekeyservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttestHardwarePrivateKeyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttestHardwarePrivateKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YubikeyAttestationRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHardwarekeyservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHardwarekeyservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHardwarekeyservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &YubikeyAttestationRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AttestationRequest = &AttestHardwarePrivateKeyRequest_YubikeyAttestationRequest{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHardwarekeyservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHardwarekeyservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *YubikeyAttestationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHardwarekeyservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: YubikeyAttestationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: YubikeyAttestationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotCert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHardwarekeyservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHardwarekeyservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthHardwarekeyservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlotCert = append(m.SlotCert[:0], dAtA[iNdEx:postIndex]...)
			if m.SlotCert == nil {
				m.SlotCert = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationCert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHardwarekeyservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHardwarekeyservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthHardwarekeyservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationCert = append(m.AttestationCert[:0], dAtA[iNdEx:postIndex]...)
			if m.AttestationCert == nil {
				m.AttestationCert = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHardwarekeyservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHardwarekeyservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttestHardwarePrivateKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHardwarekeyservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttestHardwarePrivateKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttestHardwarePrivateKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipHardwarekeyservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHardwarekeyservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPrivateKeyPolicyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHardwarekeyservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPrivateKeyPolicyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPrivateKeyPolicyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipHardwarekeyservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHardwarekeyservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPrivateKeyPolicyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHardwarekeyservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPrivateKeyPolicyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPrivateKeyPolicyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			m.Policy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHardwarekeyservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Policy |= PrivateKeyPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHardwarekeyservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHardwarekeyservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipHardwarekeyservice(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowHardwarekeyservice
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHardwarekeyservice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHardwarekeyservice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthHardwarekeyservice
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupHardwarekeyservice
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthHardwarekeyservice
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthHardwarekeyservice        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowHardwarekeyservice          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupHardwarekeyservice = fmt.Errorf("proto: unexpected end of group")
)
